# 2. greenlet

此模块是协程的最初版本, 使用`swith`手动切换执行函数, 特点:

* 多线程中创建出来的每个协程是孤立的, 不能互通, 只能于用本线程创建的协程
* 不能在循环中使用, 官方特意声明的
* 需要手动切换, 每个`switch`只执行自己创建协程时输入的函数

**示例**

```python
import threading
import time
import greenlet

def demo1():
    print("[INFO] get {}".format("www.baidu.com"))
    time.sleep(1)
    print("[INFO] complete {}".format("www.baidu.com"))
    print("demo", threading.current_thread().name)

def demo2():
    print("[INFO] get1 {}".format("www.baidu.com"))
    time.sleep(1)
    print("[INFO] complete1 {}".format("www.baidu.com"))
    print("demo", threading.current_thread().name)

a = []
for i in range(3):
    g = greenlet.greenlet(demo1)
    a.append(g)
    g = greenlet.greenlet(demo2)
    a.append(g)
[g.switch() for g in a]
```

# 3. gevent

## 3.1 协程创建

由于`greenlet`缺点比较多, 所以后期有人迭代开发了`gevent`, 特点:

* 优化智能切换
* 但是只能识别自己的延时操作`gevent.time()`, 无法识别`time.sleep`

**示例**

```python
import gevent

def demo1(a, b):
    print("[INFO] get {}".format("www.baidu.com"))
    gevent.sleep(1)
    print("[INFO] complete {}".format("www.baidu.com"))
    return a, b

g_list = []
for i in range(10):
    g = gevent.spawn(demo1, 1, 2)
    g.start()
    g_list.append(g)
gevent.iwait(None)
```

对于网络IO可以开启非阻塞模式, 使用`monkey.patch_all()`(对`socket`设置`setblocking=False`操作) 
注意:

- 所有使用`socket`的包需要在`patch_all()`之前导入
- `gevent`支持其他延迟操作, 除了`input`

**示例**

```python
import time
import gevent
from gevent import monkey

monkey.patch_all()


def test_gevent(a, *, b):
    print(1111)
    time.sleep(1)
    print(2222)


g_list = []
for i in range(10):
    g = gevent.spawn(test_gevent, 1, b=1)
    g.start()
    g_list.append(g)
[g.join() for g in g_list]
```

## 3.2 实例

### 3.2.1 gevent