# 1. Coroutine

自从Python3.4以后, Python引入了`asyncio`, 为了将语义更加明确, Python3.5正式引入协程语法`async`与`await`, 作为关键字.

注意事项:

* `async`函数不能出现`yield`/`yield from`
* `async`函数不支持耗时操作
* `async`函数其他关键字: `async for`, `async with`
* `async`函数相关的三方库: `aiohttp`, `aiomysql` ... 等

协程创建三要素:

* 创建异步任务. `create_task/ensure_future/Coroutine(asyc def)`. 异步任务构建
* 将**所有耗时任务**使用`await`进行监听操作. 监听异步事件.

* 使用`asyncio.run`开启事件监听. 函数的入口点

**示例**

```python
import asyncio


async def requests(url, t):
    await asyncio.sleep(t)
    print("wait: {}s".format(t), url)
    return url


async def main():
    print("hello")
    task1 = asyncio.create_task(requests("http://www.baidu.com22", 2))
    task2 = asyncio.create_task(requests("http://www.baidu.com11", 1))
    await task1
    await task2
    print("world")


asyncio.run(main())
```

输出

```python
hello
wait: 1s http://www.baidu.com11
wait: 2s http://www.baidu.com22
world
```

## 1.1 await

关键字`await`主要用于异步等待此函数的执行, 并在适当的时候回调回来继续执行. 可接受类型:

1. 协程
   * `async def`创建的协程
   * `asyncio.coroutine`装饰转化为的协程
2. task
   * `asyncio.create_task`创建的`task`对象
3. future
   * `asyncio.ensure_future`创建的对象

**示例**

```python
async def async_func(url):
    """协程"""
    return url

@asyncio.coroutine
def trans_async_func_for_asyncio(url):
    """使用asyncio转化的协程"""
    return url

async def test_task_obj(url):
    """测试task对象"""
    await asyncio.sleep(2)
    return url

async def test_future_obj(url):
    """测试futur对象"""
    await asyncio.sleep(2)
    return url

async def main():
    print("hello")
    print(await async_func("http://www.baidu.com1"))
    print(await trans_async_func_for_asyncio("http://www.baidu.com2"))
    task = asyncio.create_task(test_task_obj("http://www.baidu.com3"))  # 注意这个中转变量不能省略
    future = asyncio.ensure_future(test_future_obj("http://www.baidu.com4"))
    print(await task)
    print(await future)
    print("world")
asyncio.run(main())
```

### 1.1.1 协程对象

#### 关键字创建

```python
async def requests(url, t):
    print("wait: {}s".format(t), url)
    return url
```

#### > coroutine

使用`coroutine`装饰创建

```python
@asyncio.coroutine
def trans_async_func_for_asyncio(url):
    """使用asyncio转化的协程"""
    return url
```

### 1.1.2 task

#### > create_task

将协程任务加入监听序列中, 当任务被执行完成后回调挂起位置继续向下执行, 而不是阻塞等待任务执行完成. 

```python
def create_task(coro, *, name=None):
return Task
```

* coro: `coroutine`, 协程对象.
* name: `str`, 用来指定`task`的名称

**示例**

```python
import asyncio


async def requests(url, t):
    await asyncio.sleep(t)
    print("wait: {}s".format(t), url)
    return url


async def main():
    task1 = asyncio.create_task(requests("http://www.baidu.com22", 2))
    task2 = asyncio.create_task(requests("http://www.baidu.com11", 1))
    await task1
    await task2

asyncio.run(main())
```

输出

```python
wait: 1s http://www.baidu.com11
wait: 2s http://www.baidu.com22
```

### 1.1.3 future

#### > ensure_future

相对于`create_task`来说, 此函数更为底层. 功能同样是连接底层回调式代码, 将协程任务加入监听序列中.

```python
def ensure_future(obj, *, loop=None):
return Future
```

* obj: `Future/Task/coroutine`, 需要异步执行的任务对象. 可以为含`_asyncio_future_blocking`属性的对象或者`Future/Task/coroutine`
* loop: `loop`, 事件监听对象.

**示例**

```python
import asyncio


async def requests(url, t):
    await asyncio.sleep(t)
    print("wait: {}s".format(t), url)
    return url


async def main():
    future1 = asyncio.ensure_future(requests("http://www.baidu.com22", 2))
    future2 = asyncio.ensure_future(requests("http://www.baidu.com11", 1))
    await asyncio.wait([future1, future2])

asyncio.run(main())
```

输出

```python
wait: 1s http://www.baidu.com11
wait: 2s http://www.baidu.com22
```

## 1.2 loop

低层级函数可被用于获取、设置或创建事件循环

### 1.2.1 监听事件

#### > new_event_loop

创建一个新的事件监听对象.

```python
def new_event_loop():
return Loop
```

#### > get_event_loop

获取当前使用的事件循环对象. 如果不存在, 则会创建一个新的对象.

```python
def get_event_loop():
return Loop
```

#### > set_event_loop

将`loop`设置为当前线程的事件监听对象.

```python
def set_event_loop(loop):
return None
```

#### > get_running_loop

获取当前线程中使用的事件监听对象, 如果没有将会引发异常.

```python
def get_running_loop():
return Loop
```



